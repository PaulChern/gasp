<<<<<<< HEAD
=======
/*
 * Copyright 2011-2014 Will Tipton, Richard Hennig, Ben Revard, Stewart Wenner

This file is part of the Genetic Algorithm for Structure and Phase Prediction (GASP).

    GASP is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    GASP is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with GASP.  If not, see <http://www.gnu.org/licenses/>.
    
    
    */

>>>>>>> 0e3189c40547bbd59ea42c4f91890d7511fb7797
package nanoxtal;

import java.io.File;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import utility.ArgumentParser;
import vasp.VaspIn;
import vasp.VaspOut;
import crystallography.Cell;

public class NanoxtalMaker {


public static void usage() {
    System.out.println("Usage: nanoxtalmaker [OPTIONS] --I <inFile>\n"	);
}
private static String inPoscar = null;

public static void main(String[] args) {
	
	/* Get input arguments */
	ArgumentParser aparser = new ArgumentParser(args);
	if (aparser.hasOption("h") || !aparser.hasOption("I")) { /* Have to have an input POSCAR */
		usage();
		System.exit(0);
	}
	inPoscar = aparser.getArgument("I");
	/*if (aparser.hasOption("d"))
		debug = true;
	if (aparser.hasOption("cart"))
		writeCart = true;
	if (aparser.hasOption("O"))
		outFile = aparser.getArgument("O");
	if (aparser.hasOption("n"))
		n = Integer.parseInt(aparser.getArgument("n"));
	if (aparser.hasOption("v"))
		v = Integer.parseInt(aparser.getArgument("v"));
	if (aparser.hasOption("r"))
		rmax = Double.parseDouble(aparser.getArgument("r")); */
	
	/* read input POSCAR into crystal */
	Cell inputCell = VaspOut.getPOSCAR(inPoscar);
	
	/* Print input cell parameters */
	System.out.printf("Primitive cell\n");
	System.out.println(inputCell.toStringJustVectors());
	
//	/* Get supercell parameters */
//	List<List<Integer>> cellCombos = null;
//	Cell outputCell = null;
//	if (!aparser.hasOption("s")) /* Get optimal supercell parameters */
//		cellCombos = getOptimalSupercell(inputCell, debug, n , v, rmax, true);
//	else if (aparser.hasArguments("s")) { /* Get supercell parameters from input */
//		List<String> inputMatrixEntries = aparser.getArguments("s");
//		if (inputMatrixEntries.size() != 9) {
//			System.out.println("Input matrix wants 9 entries.");
//			return;
//		}
//		cellCombos = new LinkedList<List<Integer>>();
//		Iterator<String> entry = inputMatrixEntries.iterator();
//		for (int i = 0; i < 3; i++) {
//			List<Integer> vector = new LinkedList<Integer>();
//			for (int j = 0; j < 3; j++) {
//				vector.add(Integer.parseInt(entry.next()));
//			}
//			cellCombos.add(vector);
//		}
//	}
//	
//	if (cellCombos != null) { /* make the supercell */
//		outputCell = Cell.getSupercell(inputCell, cellCombos);
//	} else {
//		outputCell = inputCell;
//	}
//	
//	// maybe rotate the cell into principle directions
//	if (rotate)
//		outputCell = outputCell.getCellRotatedIntoPrincDirs();
//	
//	// maybe 
//	if (niggliReduce)
//		outputCell = outputCell.getNigliReducedCell();
//	
//	// Print output
//	if (cellCombos != null) {
//		System.out.printf("Supercell\n");
//		System.out.printf("  N = (%d %d %d)\n      (%d %d %d)\n      (%d %d %d)\n",
//			 cellCombos.get(0).get(0),cellCombos.get(0).get(1),cellCombos.get(0).get(2),
//			 cellCombos.get(1).get(0),cellCombos.get(1).get(1),cellCombos.get(1).get(2),
//			 cellCombos.get(2).get(0),cellCombos.get(2).get(1),cellCombos.get(2).get(2));
//		System.out.println(outputCell.toStringJustVectors());
//	}	
	
	// maybe write an output file
//	if (outFile != null) {
//	
//		/* check to make sure the output file doesn't already exist */
//		if ((new File(outFile)).exists()) {
//			System.out.println("Error: Output file " + outFile + " exists.  Not writing output.");
//			return;
//		}
//		
//		/* write output poscar or cif */
//		if (aparser.hasOption("c")) {
//			outputCell.writeCIF(outFile);
//			System.out.println("Wrote output CIF to: " + outFile + "\n");
//		} else {
//			VaspIn vaspin = new VaspIn(outputCell, "Autogenerated Supercell\n", null, null, null);
//			vaspin.writePoscar(outFile, writeCart);
//			System.out.println("Wrote output POSCAR to: " + outFile + "\n");
//		}
//		
//		/* sanity check for good measure */
//		if (aparser.hasOption("v") && v * inputCell.getBasisSize() != outputCell.getBasisSize()) {
//			throw new RuntimeException("SupercellOptimizer: v * inputCell.getBasisSize() != outputCell.getBasisSize()");
//		}
//	}
}
}
//ToDo: input : supercell, surface cleavage, ligand binding and orientation (or supercell and infinite plane with bound ligands)
//		manipulate: put supercell, cleavage and ligands together (or parse plane and add to cleaved supercell)
//		output: nanoxtal