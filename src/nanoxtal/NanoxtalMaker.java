package nanoxtal;

import java.io.File;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import utility.ArgumentParser;
import vasp.VaspIn;
import vasp.VaspOut;
import crystallography.Cell;

public class NanoxtalMaker {


public static void usage() {
    System.out.println("Usage: nanoxtalmaker [OPTIONS] --I <inFile>\n"	);
}

public static void main(String[] args) {
	
	/* Get input arguments */
	ArgumentParser aparser = new ArgumentParser(args);
	if (aparser.hasOption("h") || !aparser.hasOption("I")) { /* Have to have an input POSCAR */
		usage();
		System.exit(0);
	}
	/*inPoscar = aparser.getArgument("I");
	if (aparser.hasOption("d"))
		debug = true;
	if (aparser.hasOption("rot"))
		rotate = true;
	if (aparser.hasOption("nig"))
		niggliReduce = true;
	if (aparser.hasOption("cart"))
		writeCart = true;
	if (aparser.hasOption("O"))
		outFile = aparser.getArgument("O");
	if (aparser.hasOption("n"))
		n = Integer.parseInt(aparser.getArgument("n"));
	if (aparser.hasOption("v"))
		v = Integer.parseInt(aparser.getArgument("v"));
	if (aparser.hasOption("r"))
		rmax = Double.parseDouble(aparser.getArgument("r")); */
	
	/* read input POSCAR into crystal */
	Cell inputCell = VaspOut.getPOSCAR(inPoscar);
	
	/* Print input cell parameters */
	System.out.printf("Primitive cell\n");
	System.out.println(inputCell.toStringJustVectors());
	
	/* Get supercell parameters */
	List<List<Integer>> cellCombos = null;
	Cell outputCell = null;
	if (!aparser.hasOption("s")) /* Get optimal supercell parameters */
		cellCombos = getOptimalSupercell(inputCell, debug, n , v, rmax, true);
	else if (aparser.hasArguments("s")) { /* Get supercell parameters from input */
		List<String> inputMatrixEntries = aparser.getArguments("s");
		if (inputMatrixEntries.size() != 9) {
			System.out.println("Input matrix wants 9 entries.");
			return;
		}
		cellCombos = new LinkedList<List<Integer>>();
		Iterator<String> entry = inputMatrixEntries.iterator();
		for (int i = 0; i < 3; i++) {
			List<Integer> vector = new LinkedList<Integer>();
			for (int j = 0; j < 3; j++) {
				vector.add(Integer.parseInt(entry.next()));
			}
			cellCombos.add(vector);
		}
	}
	
	if (cellCombos != null) { /* make the supercell */
		outputCell = Cell.getSupercell(inputCell, cellCombos);
	} else {
		outputCell = inputCell;
	}
	
	// maybe rotate the cell into principle directions
	if (rotate)
		outputCell = outputCell.getCellRotatedIntoPrincDirs();
	
	// maybe 
	if (niggliReduce)
		outputCell = outputCell.getNigliReducedCell();
	
	// Print output
	if (cellCombos != null) {
		System.out.printf("Supercell\n");
		System.out.printf("  N = (%d %d %d)\n      (%d %d %d)\n      (%d %d %d)\n",
			 cellCombos.get(0).get(0),cellCombos.get(0).get(1),cellCombos.get(0).get(2),
			 cellCombos.get(1).get(0),cellCombos.get(1).get(1),cellCombos.get(1).get(2),
			 cellCombos.get(2).get(0),cellCombos.get(2).get(1),cellCombos.get(2).get(2));
		System.out.println(outputCell.toStringJustVectors());
	}	
	
	// maybe write an output file
	if (outFile != null) {
	
		/* check to make sure the output file doesn't already exist */
		if ((new File(outFile)).exists()) {
			System.out.println("Error: Output file " + outFile + " exists.  Not writing output.");
			return;
		}
		
		/* write output poscar or cif */
		if (aparser.hasOption("c")) {
			outputCell.writeCIF(outFile);
			System.out.println("Wrote output CIF to: " + outFile + "\n");
		} else {
			VaspIn vaspin = new VaspIn(outputCell, "Autogenerated Supercell\n", null, null, null);
			vaspin.writePoscar(outFile, writeCart);
			System.out.println("Wrote output POSCAR to: " + outFile + "\n");
		}
		
		/* sanity check for good measure */
		if (aparser.hasOption("v") && v * inputCell.getBasisSize() != outputCell.getBasisSize()) {
			throw new RuntimeException("SupercellOptimizer: v * inputCell.getBasisSize() != outputCell.getBasisSize()");
		}
	}
}
}
